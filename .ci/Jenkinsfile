#!/usr/bin/env groovy

@Library('apm@current') _

pipeline {
  agent { label 'ubuntu-18 && immutable' }
  environment {
    REPO = "synthetics"
    BASE_DIR = "src/github.com/elastic/${env.REPO}"
    PIPELINE_LOG_LEVEL = 'INFO'
    DOCKERELASTIC_SECRET = 'secret/observability-team/ci/docker-registry/prod'
    DOCKER_REGISTRY = 'docker.elastic.co'
    NODE_DOCKER_IMAGE = "${env.DOCKER_REGISTRY}/observability-ci/node-cypress:latest"
    SECCOMP_FILE = "${env.WORKSPACE}/${env.BASE_DIR}/.ci/seccomp_profile.json"
    DOCKER_IMG = "${env.DOCKER_REGISTRY}/observability-ci/synthetics"
    DOCKER_IMG_PUBLIC = "${env.DOCKER_REGISTRY}/experimental/synthetics"
    NPMRC_SECRET = 'secret/jenkins-ci/npmjs/elasticmachine'
    TOTP_SECRET = 'totp/code/npmjs-elasticmachine'
  }
  options {
    timeout(time: 12, unit: 'HOURS')  // to support releases then we will add a timeout in each stage
    buildDiscarder(logRotator(numToKeepStr: '20', artifactNumToKeepStr: '20', daysToKeepStr: '30'))
    timestamps()
    ansiColor('xterm')
    disableResume()
    durabilityHint('PERFORMANCE_OPTIMIZED')
    rateLimitBuilds(throttle: [count: 60, durationName: 'hour', userBoost: true])
    quietPeriod(10)
  }
  triggers {
    issueCommentTrigger('(?i)(^/test$)')
    upstream("apm-agent-rum/heartbeat-elastic-synthetics/${ env.JOB_BASE_NAME.startsWith('PR-') ? 'none' : 'heartbeat-synthetics' }, apm-agent-rum/heartbeat-elastic-synthetics/${ env.JOB_BASE_NAME.startsWith('PR-') ? 'none' : 'heartbeat-synthetics' }-7.x")
  }
  parameters {
    booleanParam(name: 'run_all_stages', defaultValue: false, description: 'Force to run all stages.')
    booleanParam(name: 'release', defaultValue: false, description: 'Release. If so, all the other parameters will be ignored when releasing from master.')
  }
  stages {
    /**
     Checkout the code and stash it, to use it on other stages.
     */
    stage('Checkout') {
      options {
        timeout(5)
      }
      steps {
        deleteDir()
        gitCheckout(basedir: "${BASE_DIR}")
        retryWithSleep(retries: 3, seconds: 5, backoff: true) {
          dockerLogin(secret: "${DOCKERELASTIC_SECRET}",
                      registry: "${DOCKER_REGISTRY}")
          withNodeEnv(){
            dir("${BASE_DIR}"){
              sh(label: 'Download dependencies',script: 'npm install')
            }
          }
        }
        stash allowEmpty: true, name: 'source', useDefaultExcludes: false, excludes: ".npm/_cacache/**,.nvm/.git/**"
      }
    }
    /**
     Checks formatting / linting.
     */
    stage('Lint') {
      options {
        timeout(5)
      }
      steps {
        withGithubNotify(context: 'Linting') {
          cleanup()
          withNodeEnv(){
            dir("${BASE_DIR}"){
              sh(label: 'Checks linting',script: 'npm run-script lint')
              preCommit(commit: "${GIT_BASE_COMMIT}", junit: true)
            }
          }
        }
      }
    }
    /**
     Build the main package
     */
    stage('Build') {
      options {
        timeout(5)
      }
      steps {
        withGithubNotify(context: 'Build') {
          cleanup()
          withNodeEnv(){
            dir("${BASE_DIR}"){
              sh(label: 'Build',script: 'npm run build')
            }
          }
        }
      }
    }
    /**
     Execute integration tests.
     */
    stage('Test') {
      options {
        timeout(5)
      }
      steps {
        withGithubNotify(context: 'Test') {
          cleanup()
          withNodeEnv(){
            dir("${BASE_DIR}"){
              sh(label: 'install jest-unit',script: 'npm add --dev jest-junit')
              sh(label: 'Runs the tests',script: './node_modules/.bin/jest --ci --reporters=default --reporters=jest-junit')
            }
          }
        }
      }
      post {
        always {
          junit(allowEmptyResults: true, keepLongStdio: true, testResults: "${BASE_DIR}/junit.xml")
        }
      }
    }
    stage('E2e Test') {
      options {
        timeout(15)
      }
      steps {
        withGithubNotify(context: 'E2e Test') {
          cleanup()
          withNodeEnv(){
            dir("${BASE_DIR}"){
              sh(label: 'set permissions', script: '''
                chmod -R ugo+rw examples
              ''')
              dir("__tests__/e2e"){
                timeout(time: 10, unit: 'MINUTES') {
                  sh(label: 'run e2e tests',script: 'npm run test')
                }
              }
            }
          }
        }
      }
    }
    /**
     Publish Docker images.
     */
    stage('Publish Docker image'){
      options {
        timeout(15)
      }
      matrix {
        agent { label 'ubuntu-18 && immutable' }
        axes {
          axis {
            name 'STACK_VERSION'
            values '8.0.0-synthetics', '7.10.0-synthetics', '7.11.0-synthetics'
          }
        }
        stages {
          stage('package'){
            steps {
              withGithubNotify(context: 'Package') {
                cleanup()
                withNodeEnv(){
                  dir("${BASE_DIR}"){
                    sh(label: 'Build',script: 'npm run build')
                    sh(label: 'Pack',script: 'npm pack')
                  }
                }
              }
            }
          }
          stage('observability-ci'){
            environment {
              DOCKER_IMG_TAG = "${env.DOCKER_IMG}:${env.GIT_BASE_COMMIT}-${env.STACK_VERSION}"
              DOCKER_IMG_TAG_BRANCH = "${env.DOCKER_IMG}:${env.BRANCH_NAME}-${env.STACK_VERSION}"
            }
            steps {
              withGithubNotify(context: "push ${DOCKER_IMG_TAG_BRANCH}") {
                pushDockerImage()
              }
            }
          }
          stage('experimental'){
            when {
              branch 'master'
            }
            environment {
              DOCKER_IMG_TAG_BRANCH = "${env.DOCKER_IMG_PUBLIC}:${env.STACK_VERSION}"
            }
            steps {
              withGithubNotify(context: "push ${DOCKER_IMG_TAG_BRANCH}") {
                pushDockerImage()
              }
            }
          }
        }
      }
    }
    stage('Release') {
      options {
        skipDefaultCheckout()
      }
      when {
        beforeAgent true
        allOf {
          branch 'master'
          expression { return params.release }
        }
      }
      stages {
        stage('Notify') {
          options { skipDefaultCheckout() }
          steps {
            notifyStatus(slackStatus: 'warning', subject: "[${env.REPO}] Release ready to be pushed",
                         body: "Please go to (<${env.BUILD_URL}input|here>) to approve or reject within 12 hours.")
          }
        }
        stage('Release CI') {
          options { skipDefaultCheckout() }
          input {
            message 'Should we release a new version?'
          }
          steps {
            cleanup()
            withNodeEnv(){
              dir("${BASE_DIR}"){
                prepareRelease() {
                  sh(script: "npm publish --otp=\${TOTP_CODE} --tag alpha", label: 'publish to NPM')
                  setEnvVar('VERSION', sh(script: '''node -p "require('./package.json').version"''', returnStdout: true).trim())
                  sh(script: "npm dist-tag add @elastic/synthetics@${VERSION} latest", label: 'retag latest')
                }
              }
            }
          }
          post {
            success {
              notifyStatus(slackStatus: 'good', subject: "[${env.REPO}] Release published", body: "Great news, the release has been done successfully. (<${env.RUN_DISPLAY_URL}|Open>). \n Release URL: (<https://github.com/elastic/apm-agent-rum-js/releases|Here>)")
            }
            always {
              script {
                currentBuild.description = "${currentBuild.description?.trim() ? currentBuild.description : ''} released"
              }
            }
          }
        }
      }
      post {
        failure {
          notifyStatus(slackStatus: 'danger', subject: "[${env.REPO}] Release failed", body: "(<${env.RUN_DISPLAY_URL}|Open>)")
        }
      }
    }
  }
  post {
    cleanup {
      notifyBuildResult(prComment: true)
    }
  }
}

def cleanup(){
  dir("${BASE_DIR}"){
    deleteDir()
  }
  unstash 'source'
}

def withNodeInDockerEnv(Map args=[:], Closure body){
  docker.image("${NODE_DOCKER_IMAGE}").inside(" --security-opt seccomp=${SECCOMP_FILE}"){
    withEnv(["HOME=${WORKSPACE}"]) {
      body()
    }
  }
}

def withNodeEnv(Map args=[:], Closure body){
  withEnv(["HOME=${WORKSPACE}"]) {
    sh(label: 'install Node.js', script: '''
      set +x
      if [ -z "$(command -v nvm)" ]; then
        curl -so- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.1/install.sh | bash
      fi

      export NVM_DIR="${HOME}/.nvm"
      [ -s "${NVM_DIR}/nvm.sh" ] && \\. "${NVM_DIR}/nvm.sh"
      nvm install --lts
      nvm version | head -n1 > .nvm-node-version
    ''')
    def node_version = readFile(file: '.nvm-node-version').trim()
    withEnv(["PATH+NVM=${HOME}/.nvm/versions/node/${node_version}/bin"]){
      body()
    }
  }
}

def pushDockerImage(){
  dir("${BASE_DIR}"){
    dockerLogin(secret: "${env.DOCKERELASTIC_SECRET}",
      registry: "${env.DOCKER_REGISTRY}")
    sh(label: 'Build Docker image',
      script: """docker build \
        -t ${env.DOCKER_IMG_TAG} \
        -t ${env.DOCKER_IMG_TAG_BRANCH} \
        --build-arg STACK_VERSION=${env.STACK_VERSION} \
        --label BRANCH_NAME=${env.BRANCH_NAME} \
        --label GIT_SHA=${env.GIT_BASE_COMMIT} \
        --label TIMESTAMP=\$(date +%Y-%m-%d_%H:%M) \
        .
    """)
    retryWithSleep(retries: 3, seconds: 5, backoff: true){
      if(env.DOCKER_IMG_TAG){
        sh(label: 'Push Docker image sha',
          script: "docker push ${env.DOCKER_IMG_TAG}")
      }
      sh(label: 'Push Docker image name',
        script: "docker push ${env.DOCKER_IMG_TAG_BRANCH}")
    }
  }
}

/**
  This is the wrapper to prepare the release context, for such, it's required
  to decouple the build environment preparation from the TOTP access, otherwise
  the TOTP might expire if it takes too long.
 */
def prepareRelease(Closure body){
  withNpmrc(secret: "${env.NPMRC_SECRET}", path: "${env.WORKSPACE}/${env.BASE_DIR}") {
    withGitRelease(credentialsId: '2a9602aa-ab9f-4e52-baf3-b71ca88469c7-UserAndToken') {
      sh(script: 'npm version prerelease --preid=alpha', label: 'bump the alpha version')
      sh(script: 'npm ci', label: 'prepare the ci environment')
      gitPush()
      gitPush(args: '--tags')
      withTotpVault(secret: "${env.TOTP_SECRET}", code_var_name: 'TOTP_CODE'){
        body()
      }
    }
  }
}

/**
  This is the wrapper to send notifications for the release process through
  slack and email, since it requires some formatting to support the same
  message in both systems.
 */
def notifyStatus(def args = [:]) {
  slackSend(channel: '#synthetics-user_experience-uptime', color: args.slackStatus, message: "${args.subject}. ${args.body}",
            tokenCredentialId: 'jenkins-slack-integration-token')
  // transform slack URL format '(<URL|description>)' to 'URL'.
  def bodyEmail = args.body.replaceAll('\\(<', '').replaceAll('\\|.*>\\)', '')
  emailext(subject: args.subject, to: 'synthrum@elastic.co', body: bodyEmail)
}
